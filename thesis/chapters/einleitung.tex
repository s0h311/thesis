\chapter{Einleitung}

\section{Die Rolle des State-Managements in Frontend Webapplikationen}

Moderne Webapplikationen beinhalten komplexe Anzeigelogik in der Präsentationsschicht. Diese Anzeigelogik erfordert viele Daten, welche in der Lebensdauer der Browser-Session ständig aktualisiert und mit den Stand des Servers in beide Richtungen synchronisiert werden müssen. Um Server Aufrufe zu sparen, können verschiedene Mechanismen, wie beispielsweise Caching und Debouncing verwendet werden. Diese Faktoren erhöhen, die ohnehin schon hohe Komplexität und Fehleranfälligkeit zusätzlich.

Um diese Komplexität effizient zu verwalten, werden State-Management Lösungen wie Redux \ref{fig:redux}, NgRx \ref{fig:ngrx} und Pinia \ref{fig:pinia} verwendet. Mit Hilfe dieser Open Source JavaScript Bibliotheken, können Daten beim Bedarf von einer API abgerufen, transformiert und im Speicher gespeichert werden. Die meisten State-Management Bibliotheken sind eng mit einem UI-Framework gekoppelt. \ref{fig:ui-frameworks-and-state-management}. Aus diesem Grund sind sie ein fundamentaler Baustein jeder (größeren) Frontend Webapplikation.

\section{Ziel dieser Arbeit}

Mit der Komplexität erhöht sich auch die Fehleranfälligkeit. Fehler im Zustand, also Daten der Applikation haben einen direkten Einfluss auf die Anzeige. Wenn die Applikation sich in einem "falschen" Zustand befindet und es keine Laufzeitfehler gab, können die Verantwortlichen (in der Regel, die Entwickler) unter Umständen, nicht darüber informiert sein. 

Ziel dieser Arbeit ist es einen Ansatz zu erarbeiten, bei dem die Möglichkeit eines Befindens in einem "falschen" oder "illegalem" Zustand eliminiert wird. Dazu wird jeder zusammenhänge Teil des Zustands als ein endlicher Automat \ref{fig:fa} abgebildet. Dahingehend wird jede Änderung in diesem Zustand wie ein Übergang bei einem endlichen Automaten behandelt.