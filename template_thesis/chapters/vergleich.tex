\chapter{Vergleich der Ansätze} \label{vergleich}

Der in vorangegangen Kapiteln vorgestellte \acrlong{ac:st} Ansatz, erweitert die interne Funktionsweise einer \acrlong{ac:sm} Lösung. Er erfordert die zusätzliche Definition einer TranisitionMap und es werden leicht geänderte APIs dem Benutzer zur Verfügung gestellt. In diesem Kapitel werden die Standard Stores (unveränderte) zu den mit S\acrlong{ac:st} verglichen. Es werden die quantifizierbare Kennzahlen Lines of Code, Bundle Size und Performance untersucht. Außerdem werden die Aspekte Developer Experience, Fehleranfälligkeit, Wartbarkeit und Lesbarkeit analysiert. Als Basis für den Vergleich dienen die unveränderten Redux und Pinia Stores.

\section{Aufbau}

Damit der Vergleich realitätsnah ist, wird eine Webapplikation mit üblichen Anforderungen wie Data-Fetching und Filterung gebaut. Die Applikation besteht aus einer Seite, welche eine Liste von 194 Produkten und Filteroptionen beinhaltet. Die Applikation fetcht und speichert die Produktdaten im Store. Die Filteroptionen sind: Titel, Preisobergrenze, Mindestbewertung, Verfügbarkeit und Kategorie.

Die Applikation wurde in React mit Redux und analog in Vue mit Pinia gebaut. Anschließend wurden die beiden Implentierungen kopiert und die Kopien um Strict-Transitions erweitert. Die quantifizierbare Kennzahlen wurden mit Hilfe von eigenen Tools, sowie Playwright und Chrome Profiling gesammelt.

\section{Quantifizierbare Aspekte}
\subsection{Lines of Code}

Bei React wurden die .js, .ts, .tsx und bei Vue die .ts und .vue Dateien untersucht. Alle anderen Dateitypen wurden ignoriert, da diese weder für die Geschäfslogik noch für die UI verantwortlich sind.

\begin{center}
  \begin{tabular}{|c|c|c|c|} 
   \hline
   Dateityp & Anzahl & LOC & Szenario \\ [0.5ex] 
   \hline\hline
   js & 1 & 25 & React without ST \\ 
   \hline
   ts & 14 & 256 & React without ST \\
   \hline
   tsx & 5 & 187 & React without ST \\
   \hline\hline
   js & 1 & 25 & React with ST \\ 
   \hline
   ts & 17 & 284 & React with ST \\
   \hline
   tsx & 5 & 187 & React with ST \\
   \hline\hline
   ts & 5 & 140 & Vue without ST \\
   \hline
   vue & 5 & 133 & Vue without ST \\
   \hline\hline
   ts & 5 & 172 & Vue with ST \\
   \hline
   tsx & 5 & 133 & Vue with ST \\
   \hline
  \end{tabular}
\end{center}

Der relative Anstieg in LOC bei React beträgt $\sim6\%$ und bei Vue $\sim12\%$. Darüber hinaus beträgt der absolute Anstieg jeweils 28 Lines und 32 Lines.

\subsection{Bundle Size}

Analysiert wurden die Production Bundles der Applikationen. Diese wurden mit dem Build Tool Vite erstellt. Alle Applikationen nutzen ausschließlich Client Side Rendering. Daher ist es wichtig, dass die Bundles klein wie möglich bleiben.

\begin{center}
  \begin{tabular}{|c|c|c|} 
   \hline
   Size in kB & Gziped & Szenario \\ [0.5ex]
   \hline\hline
   156,26 & 51,22 & React without ST \\
   \hline
   157,24 & 51,54 & React with ST \\
   \hline
   70,43 & 28,23 & Vue without ST \\
   \hline
   71,16 & 28,5 & Vue with ST \\
   \hline
  \end{tabular}
\end{center}

Der relative Anstiegt bei React beträgt $\sim0,6\%$ und bei Vue $\sim1\%$. Darüber hinaus beträgt der absolute Anstieg jeweils 0,98kB und 0,73kB. Der Anstieg in Bundle Size ist vernachlässigbar.

\subsection{Performance}

Um den Unterschied in Performance zu messen, wurde das Testing Tool Playwright verwendet. Mit Hilfe von Playwright wurde ein Szenario definiert. In diesem wurden alle Features der Webseite verwendet, welche Actions in Stores verursachen. Das Szenario wurde pro Applikation 20 Mal ausgeführt. Es lief im Chrome Browser und wurde mit Hilfe des Performance Tabs in den Chrome DevTools analysiert. Es wurden die Mittelwerte für Ausführungszeit in Millisekunden für die Browsertasks Scripting, Painting und Rendering ermittelt.

React Redux:

\begin{center}
  \begin{tabular}{|c|c|c|c|} 
   \hline
   Task & ms ohne ST & mit ST & Delta \\ [0.5ex]
   \hline\hline
   Scripting & 1.111,45 & 1.121,35 & +0,89\% \\
   \hline
   Painting & 858,05 & 841,05 & -1,98\% \\
   \hline
   Rendering & 613,25 & 611,05 & -0,36\% \\
   \hline
  \end{tabular}
\end{center}

Vue Pinia:

\begin{center}
  \begin{tabular}{|c|c|c|c|} 
   \hline
   Task & ohne ST & mit ST & Delta \\ [0.5ex]
   \hline\hline
   Scripting & 1.680,15 & 1.677,95 & -0,13\% \\
   \hline
   Painting & 777,65 & 763,65 & -1,80\% \\
   \hline
   Rendering & 651,65 & 642,9 & -1,34\% \\
   \hline
  \end{tabular}
\end{center}

In allen Browsertasks, ausgenommen Scripting bei React, kann ein Rückgang in der Ausführungszeit beobachtet werden. Allerdings ist der Unterschied vernachlässigbar, da dieser sehr gering ist. Auch der Anstieg im Scripting bei React ist mit 0,89\% ebenfalls vernachlässigbar.

Die Gerätspezifikation und Versionen der verwendeten Technologien ist wie folgt:

\begin{center}
  \begin{tabular}{ | m{5cm}| m{5cm} | } 
    \hline
    Gerät & Apple Macbook Pro 2023 mit M3 CPU und 24GB Speicher \\ 
    \hline
    Betriebssystem & MacOS 15.3 \\ 
    \hline
    Docker & 27.4.1 \\ 
    \hline
    OrbStack & 1.9.5 \\ 
    \hline
    Nginx & 1.27.3 \\ 
    \hline
    Chrome Canary & 134.0.6994.0 \\ 
    \hline
    Playwright & 1.50.0 \\ 
    \hline
    Node & 20.17.0 \\ 
    \hline
    Vite & 6.0.5 \\ 
    \hline
    React & 18.3.1 \\ 
    \hline
    Redux & 5.0.1 \\ 
    \hline
    React Redux & 9.2.0 \\ 
    \hline
    Vue & 3.5.13 \\ 
    \hline
    Pinia & 2.3.1 \\ 
    \hline
  \end{tabular}
\end{center}

\section{Qualitative Aspekte}

\subsection{Developer Experience (DX)}
Die Developer Experience wird durch die zusätzliche Aufgabe der Definition einer Transition Map beeinflusst. Sie führt zu mehr Code und somit zu zusätzlicher Aufwand.

\subsection{Fehleranfälligkeit}
Vorausgesetzt die Transition Map bildet die zulässigen Übergänge vollständig und korrekt ab, kann sich die Applikation nicht in einem unzulässigen Zustand befinden. Obwohl sich hiermit die Fehlerstelle verlegt, ist diese Zentral und nicht an vielen Orten verteilt. Falls sich die Applikation in einem falschen Zustand befindet, ist die Transition Map an einem zentralen Ort zu überprüfen statt die ausgelösten Actions an vielen Orten.

Darüber hinaus bildet die Transition Map die Abläufe in der Applikation ab und kann für eine bessere Nachvollziehbarkeit sorgen. Außerdem ist die Transition Map ein POJO und kann somit ohne weiteres Mocking getestet werden.

\subsection{Lesbarkeit}
Die Lesbarkeit des gesamten Applikationscodes bleibt unverändert, ausgenommen ist die hinzukommende Transition Map. Die Lesbarkeit der Transition Map wird hauptsächlich durch die enthaltene Identitätsfunktionen beeinflusst. Für diese wird der Einsatz von Pure Functions mit geringen Abzweigungen und Funktionsaufrufen empfohlen. Wenn dies eingehalten wird, ist die zyklomatische Komplexität gering, was in der Regel eine bessere Lesbarkeit impliziert. Jedoch hängt die Lesbarkeit stark von den Konventionen und dem Code Style des Authors ab.

\subsection{Wartbarkeit}
Jede hinzukommende Action oder State muss in der Transition Map berücksichtigt werden. Daher steigt die Wartbarkeit.
