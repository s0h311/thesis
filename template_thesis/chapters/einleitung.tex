\chapter{Einleitung}

\section{Die Rolle des State-Managements in Frontend-Webapplikationen}

% Warum ist SM benötigt?
Moderne Webseiten folgen dem \acrlong{ac:spa}-Ansatz. Demnach bleibt die gleiche Instanz der Webapplikation bestehen, solange der Nutzer auf der Webseite ist. In der Regel sind mehrere Teile einer Applikation, beispielsweise bei der Komponenten-Architektur, von denselben Daten abhängig. Außerdem werden die Daten basierend auf Interaktionen des Benutzers modifiziert. Änderungen in den Daten müssen den betroffenen Komponenten mitgeteilt werden. In einigen Fällen ist die Synchronisierung der Daten im Frontend mit den Daten des Servers erforderlich. Um HTTP-Aufrufe zu sparen, können verschiedene Mechanismen wie beispielsweise Caching oder Debouncing verwendet werden. Diese Faktoren erhöhen die ohnehin schon hohe Komplexität und Fehleranfälligkeit zusätzlich.

Um diese Komplexität effizient zu verwalten, werden \acrlong{ac:sm}-Lösungen wie Redux, NgRx, Zustand oder Pinia verwendet. Mithilfe dieser Open-Source-\acrlong{ac:js}-Bibliotheken können Daten bei Bedarf von einer API abgerufen, transformiert und gespeichert werden. Die meisten \acrlong{ac:sm}-Bibliotheken sind eng mit einem UI-Framework gekoppelt. Aus diesem Grund sind sie ein fundamentaler Baustein jeder größeren Frontend-Webapplikation.

\section{Ziel der Arbeit}

Mit der Komplexität erhöht sich auch die Fehleranfälligkeit. Fehler im Zustand, also in den Daten der Applikation, haben einen direkten Einfluss auf das Angezeigte. Wenn die Applikation sich in einem inkorrekten Zustand befindet und es keine Laufzeitfehler gab, können die Verantwortlichen (in der Regel die Entwickler) unter Umständen nicht darüber informiert sein. Dies führt zu langlebigen Bugs.

Ziel dieser Arbeit ist es, einen Ansatz zu erarbeiten, bei dem die Möglichkeit eines inkorrekten Zustands eliminiert wird. Dazu wird jeder zusammenhängende Teil des Zustands als ein \acrlong{ac:dfa} abgebildet. Dahingehend wird jede Änderung in diesem Zustand wie ein Übergang bei einem endlichen Automaten behandelt. Es wird vorgeschlagen, die beliebten \acrlong{ac:sm}-Lösungen um \textit{strikte} Übergänge (\acrshort{ac:st}), wie bei einem \acrshort{ac:dfa}, zu erweitern. Auf diesem Wege wird eine Reduzierung von Bugs in größeren Applikationen angestrebt. Dabei wird insbesondere auf die Lesbarkeit und Wartbarkeit des Quellcodes sowie die \acrlong{ac:dx} geachtet.

Folgende Forschungsfragen werden behandelt:

\begin{enumerate}
  \item Können Bugs, die aufgrund eines falschen Zustands entstehen, mithilfe von Strict Transitions reduziert werden?
  \item Steigt oder sinkt die \acrshort{ac:dx} durch die Einführung von Strict Transitions?
  \item Steigt oder sinkt die Lesbarkeit und Wartbarkeit des Codes durch die Einführung von Strict Transitions?
\end{enumerate}

\section{Aufbau}

In dieser Arbeit werden die bestehenden \acrshort{ac:sm}-Ansätze um Übergänge wie bei einem \acrshort{ac:dfa} erweitert. Um dies zu erreichen, ist es notwendig, die Funktionsweise bestehender Ansätze zu kennen. Diese werden in Kapitel \ref{sm-ansaetze} aufgeführt. Anschließend werden die \acrshort{ac:dfa}-Übergänge, angepasst an den Anwendungsfall, einschließlich der \acrlong{ac:js}-API zur Definition in Kapitel \ref{ch:strict-transitions} dargestellt. Die Erkenntnisse aus Kapitel \ref{sm-ansaetze} und \ref{ch:strict-transitions} werden kombiniert, um zwei konkrete Implementierungen für Redux und Pinia zu zeigen. Danach wird der ST-Ansatz in Kapitel \ref{vergleich} mit dem normalen Ansatz verglichen. Bei dem Vergleich werden die quantitativen und qualitativen Aspekte analysiert, wobei die Bewertung der qualitativen Aspekte auf den üblichen Coding-Standards, Konventionen und Konzepten basiert. Abschließend werden die oben aufgeführten Forschungsfragen in Kapitel \ref{ch:fazit} basierend auf dem Vergleich beantwortet und ein Fazit gezogen.
