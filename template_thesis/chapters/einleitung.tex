\chapter{Einleitung}

\section{Die Rolle des State-Managements in Frontend Webapplikationen}

% Warum ist SM benötig?
Moderne Webseiten folgen dem \acrlong{ac:spa} Ansatz. Dem nach bleibt die gleiche Instanz der Webapplikation solange der Nutzer auf der Webseite ist, bestehen. In der Regel sind mehrere Teile einer Applikation, beispielsweise bei der Komponenten-Architektur, von gleichen Daten abhängig. Außerdem werden die Daten basierend auf Interaktionen des Benutzers modifiziert. Änderungen in den Daten müssen den betroffenen Komponenten mitgeteilt werden. In einigen Fällen ist die Synchronisierung der Daten im Frontend mit den Daten des Servers erforderlich. Um HTTP Aufrufe zu sparen, können verschiedene Mechanismen, wie beispielsweise Caching oder Debouncing verwendet werden. Diese Faktoren erhöhen, die ohnehin schon hohe Komplexität und Fehleranfälligkeit zusätzlich.

Um diese Komplexität effizient zu verwalten, werden \acrlong{ac:sm} Lösungen wie Redux, NgRx, Zustand oder Pinia verwendet. Mit Hilfe dieser Open Source \acrlong{ac:js} Bibliotheken, können Daten beim Bedarf von einer API abgerufen, transformiert und gespeichert werden. Die meisten \acrlong{ac:sm} Bibliotheken sind eng mit einem UI-Framework gekoppelt. Aus diesem Grund sind sie ein fundamentaler Baustein jeder größeren Frontend Webapplikation.

\section{Ziel der Arbeit}

Mit der Komplexität erhöht sich auch die Fehleranfälligkeit. Fehler im Zustand, also Daten der Applikation, haben einen direkten Einfluss auf das Angezeigte. Wenn die Applikation sich in einem \q{falschen} Zustand befindet und es keine Laufzeitfehler gab, können die Verantwortlichen (in der Regel, die Entwickler) unter Umständen, nicht darüber informiert sein. Dies führt zu langlebigen Bugs.

Ziel dieser Arbeit ist es, einen Ansatz zu erarbeiten, bei dem die Möglichkeit eines Befindens in einem \q{falschen} oder \q{illegalem} Zustand eliminiert wird. Dazu wird jeder zusammenhänge Teil des Zustands als ein \acrlong{ac:dfa} abgebildet. Dahingehend wird jede Änderung in diesem Zustand wie ein Übergang bei einem endlichen Automaten behandelt. Es wird vorgeschlagen die beliebten \acrlong{ac:sm} Lösungen um \q{strikte} Übergänge (\acrshort{ac:st}), wie bei einem \acrlong{ac:dfa}, zu erweitern. Auf diesem Wege wird eine Reduzierung von Bugs in größeren Applikationen bestrebt. Dabei wird insbesondere auf die Lesbarkeit und Wartbarkeit des Quellcodes und die \acrlong{ac:dx} geachtet.

Folgende Forschungsfragen werden behandelt:

\begin{enumerate}
  \item Können Bugs, die Aufgrund eines falschen Zustandes entstehen, mit Hilfe von Strict Transitions reduziert werden?
  \item Steigt oder sinkt die \acrshort{ac:dx} durch die Einführung von Strict Transitions?
  \item Steigt oder sinkt die Lesbarkeit und Wartbarkeit des Codes durch die Einführung von Strict Transitions?
\end{enumerate}

\section{Aufbau}

In dieser Arbeit werden die bestehende \acrshort{ac:sm} Ansätze um Übergänge wie bei einem \acrshort{ac:dfa} erweitert. Um dies zu erreichen, ist es notwendig die Funktionsweise bestehender Ansätze zu kennen. Diese werden im Kapitel \ref{sm-ansaetze} aufgeführt. Anschließend werden die \acrlong{ac:dfa}-Übergänge angepasst auf Anwendungfall einschließlich der \acrlong{ac:js} API zur Definition im Kapitel \ref{ch:strict-transitions} dargestellt. Die Erkenntnisse aus Kapitel \ref{sm-ansaetze} und \ref{ch:strict-transitions} werden kombiniert, um zwei konkrete Implementierungen für Redux und Pinia zu zeigen. Danach wird der ST Ansatz im Kapitel \ref{vergleich} mit dem normalen Ansatz verglichen. Bei dem Vergleich werden die quantitative und qualitative Aspekte analysiert. Wobei die Bewertung der qualitativen Aspekte auf die üblichen Coding Standards, Konventionen und Konzepte basieren. Abschließend werden die oben aufgeführten Forschungsfragen im Kapitel \ref{ch:fazit} basierend auf den Vergleich beantwortet und ein Fazit gezogen.

